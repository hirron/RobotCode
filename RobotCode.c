#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, in2,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl3,  StateLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Motor,  port10,           motor1,        tmotorVex393, openLoop)
#pragma config(Motor,  port2,           motor2,        tmotorVex393, openLoop)
#pragma config(Motor,  port3,           motor3,        tmotorVex393, openLoop)
#pragma config(Sensor, S3,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int sweep=0; // determines which direction robot is sweeping in
int PeakReading=0;
int VSonar=255;


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released.
*       - Note that this function only sets button1_pushed and button2_pushed flags to true.
*         Your code should clear these flags by setting the appropriate variable to false after
*         the appropriate action has been taken.
*/



typedef enum{
	StartState=0,
	AlignState,
	MoveState,
	DropState,
	ParkState,
	EndState,
	DeadState

}T_FSMState;

T_FSMState FSMState;





void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) & !button2_pushed)
	{
		button2_pushed = true;
	}
}

void Turn(int Dir)
{
	clearTimer(T1);
	//1 is a left turn, 0 is a right turn
	if(Dir==1){
		// turns front wheel
		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= -50;
		}
		// goes forward, turning robot
		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		// realigns front wheel to default state
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= 43;
		}
		motor[motor2]= 0;
		}else{
		
		// same thing in opposite direction
		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= 50;
		}

		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= -43;
		}
		motor[motor2]= 0;
		}
}

// sets the front wheel to 90 degrees to enable on spot turning
void SpotRot(bool Start){

	clearTimer(T1);

	while (time1[T1]<=1000){
		if(Start==true){
			motor[motor2]=50;
			}else{
			motor[motor2]=-50;
		}
	}
	motor[motor2]= 0;
}




task main()
{
	button1_pushed = button2_pushed = false;

	while(true){
		switch(FSMState){



		case StartState:
			monitorInput();
			if(button1_pushed==true){
				Turn(1);
				}else if(button2_pushed==true){
				Turn(0);
				}else{ 
				//turns wheel to 90 degrees, transitions to align state
				SpotRot(true);
				FSMState=AlignState;
			}
			break;


			// Detects peak of IR (when robot is best facing sensor)
		case AlignState:
			monitorInput();
			int SensorAv=((SensorValue[in1]+SensorValue[in2])/2);
			motor[motor1]=10;

			// if new peak is achieved it is recorded
			if(SensorAv>PeakReading){
				PeakReading=SensorAv;

				// once significant dropoff occurs wheel goes streight and transitions to move state
				}else if(SensorAv<PeakReading-50){
				motor[motor1]=0;
				SpotRot(false);
				break;



			case MoveState:
				monitorInput();
				int static motorSpeed=50; // function ( to be made) slows speed as robot draws nearer
				motor[motor1]=motorSpeed;

				// when led values reach a point, motor is shut off. drop state entered
				if(SensorValue[in1]>5000){
					motor[motor1]=0;
					FSMState=DropState;
				}
				break;


				//Defines behavior when dropping object
			case DropState:
				clearTimer(T1);

				// waits a bit of time before dropping
				while (time1[T1]>=1500&&time1[T1]<=1750){
					motor[motor1]= 0;
					motor[motor3]= -50;
				}
				//after letting go will reverse away from beacon
				while (time1[T1]>=1750&&time1[T1]<=2250){
					motor[motor1]= -50;
					motor[motor3]= 0;
					//  motor[motor2]= 5
				}

				motor[motor1]= 0;

				// transitions to looking to park
				FSMState=ParkState;

				break;

			case ParkState:
				monitorInput();
				//Turns robot left so that it doesn't run into beacon
				Turn(1);
				// if wall is too distant turn
				if(SensorValue[S3]==255){
					Turn(1);
				}
				while(SensorValue[S3]<255)
					//while over a meter away rapidly approches wall
				if(SensorValue[S3]>100){
					motor[motor1]=120;
				}
				// slows down at a meter
				if(SensorValue[S3]<100){
					motor[motor1]=60;
				}
				// stops motor at 15 cm distance
				if(SensorValue[S3]<15){
					motor[motor1]=0;
					SpotRot(true);		// prepares for aligning robot
					FSMState=EndState;
				}

				break;


			case EndState:
				// Sweep tells robot which direction to turn in
				if(sweep==0){
					motor[motor1]=50;
					}else{
					motor[motor1]=-50;
				}
				// if distance to wall is growing so is angle from wall, thus it is either time to stop
				// or move in other direction
				if(SensorValue[S3]<VSonar){
					VSonar=SensorValue[S3];
					// flags that robot was moving in right direction
					sweep=2;
				}
				if(SensorValue[S3]>VSonar){
					//if robot was moving in wrong direction, robot changes direction
					if(sweep==0){
						sweep=1;
					}
					// if robot was moving in right direction it has reached end
					if(sweep==2){
						motor[motor1]=0;
						FSMState = DeadState;
					}
				}

				break;
				// Robot stops all motors
			case DeadState:
				motor[motor1]=0;
				motor[motor2]=0;
			}
		}
	}
}
