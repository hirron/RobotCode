#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, in2,    InfraCollector, sensorReflection)
#pragma config(Sensor, in7,    ,               sensorAnalog)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl6,  S3,             sensorSONAR_cm)
#pragma config(Motor,  port1,           motor2,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor1,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int sweep=0; // determines which direction robot is sweeping in
int PeakReading=0;
int VSonar=255;


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released.
*       - Note that this function only sets button1_pushed and button2_pushed flags to true.
*         Your code should clear these flags by setting the appropriate variable to false after
*         the appropriate action has been taken.
*/



typedef enum{
	StartState=0,
	AlignState,
	MoveState,
	DropState,
	ParkState,
	EndState,
	DeadState,

}T_FSMState;

T_FSMState FSMState;







void Turn(int Dir)
{
	clearTimer(T1);
	//1 is a left turn, 0 is a right turn
	if(Dir==1){
		// turns front wheel
		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= -50;
		}
		// goes forward, turning robot
		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		// realigns front wheel to default state
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= 43;
		}
		motor[motor2]= 0;
		}else{

		// same thing in opposite direction
		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= 50;
		}

		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= -43;
		}
		motor[motor2]= 0;
	}
}

// sets the front wheel to 90 degrees to enable on spot turning
void SpotRot(bool Start){

	clearTimer(T1);

	while (time1[T1]<=1200){
		if(Start==true){
			motor[motor2]=-50;
			}else{
			motor[motor2]=50;
		}
		if(button1_pushed==true||button2_pushed==true){
			motor[motor2]=0;
			motor[motor1]=0;
			motor[motor3]=0;
		}
	}
	motor[motor2]= 0;
}

void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		Turn(1);
	}

	if(SensorValue(button2) & !button2_pushed)
	{
		Turn(0);
	}
}


task main()
{
	button1_pushed = button2_pushed = false;

	while(true){

		switch(FSMState){
		default:
			FSMState=StartState;
			break;

		case StartState:
			monitorInput();
			//turns wheel to 90 degrees, transitions to align state
			SpotRot(true);
			FSMState=ParkState;// change this back to AlignState

			break;


			// Detects peak of IR (when robot is best facing sensor)
		case AlignState:
			monitorInput();
			int SensorAv=((SensorValue[in1]+SensorValue[in2])/2);
			motor[motor1]=20;

			// if new peak is achieved it is recorded
			if(SensorAv>PeakReading){
				PeakReading=SensorAv;

				// once significant dropoff occurs wheel goes streight and transitions to move state
				}else if(SensorAv<PeakReading-50){
				motor[motor1]=0;
				SpotRot(false);
				FSMState=MoveState;
			}

			break;



		case MoveState:
			monitorInput();
			int static motorSpeed=(100-(SensorValue[in1]/1600)); // function ( to be made) slows speed as robot draws nearer
			motor[motor1]=motorSpeed;

			// when led values reach a point, motor is shut off. drop state entered
			if(SensorValue[in1]>4000){
				motor[motor1]=0;
				FSMState=DropState;
			}
			break;


			//Defines behavior when dropping object
		case DropState:
			clearTimer(T1);

			// waits a bit of time before dropping
			while (time1[T1]>=1500&&time1[T1]<=1750){
				motor[motor1]= 0;
				motor[motor3]= -50;
			}
			//after letting go will reverse away from beacon
			while (time1[T1]>=1750&&time1[T1]<=2250){
				motor[motor1]= -50;
				motor[motor3]= 0;
				//  motor[motor2]= 5
			}

			motor[motor1]= 0;

			// transitions to looking to park
			FSMState=ParkState;

			break;

		case ParkState:
			monitorInput();
			//Turns robot left so that it doesn't run into beacon
			Turn(1);
			// if wall is too distant turn
			if(SensorValue[dgtl3]==255){
				Turn(1);
			}
			while(SensorValue[S3]<255){
				//while over a meter away rapidly approches wall

				if(SensorValue[S3]<100){
					motor[motor1]=60;
					if(SensorValue[S3]>100){
						motor[motor1]=120;
					}
					// slows down at a meter

				}
				// stops motor at 15 cm distance
				if(SensorValue[S3]<20&&SensorValue[S3]!=-1){
					motor[motor1]=0;
					SpotRot(true);		// prepares for aligning robot
					FSMState=EndState;
				}
			}

			break;


		case EndState:
			// Sweep tells robot which direction to turn in
			if(sweep==0){
				motor[motor1]=20;
				}else{
				motor[motor1]=-20;
			}
			// if distance to wall is growing so is angle from wall, thus it is either time to stop
			// or move in other direction
			if(SensorValue[S3]<VSonar){
				VSonar=SensorValue[S3];
				// flags that robot was moving in right direction
				sweep=2;
			}
			if(SensorValue[S3]>(VSonar+5)){
				//if robot was moving in wrong direction, robot changes direction
				if(sweep==0){
					sweep=1;
				}
				// if robot was moving in right direction it has reached end
				if(sweep==2){
					motor[motor1]=0;
					FSMState = DeadState;
				}
			}

			break;
			// Robot stops all motors
		case DeadState:
			motor[motor2]=0;
			while(SensorValue[button1]==1){
				motor[motor2]=20;
			}
			while(SensorValue[button2]==true){
				motor[motor2]=-20;
			}
			motor[motor1]=0;
		}
	}
}
