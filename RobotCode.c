#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, in2,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl3,  StateLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Motor,  port10,           motor1,        tmotorVex393, openLoop)
#pragma config(Motor,  port2,           motor2,        tmotorVex393, openLoop)
#pragma config(Motor,  port3,           motor3,        tmotorVex393, openLoop)
#pragma config(Sensor, S3,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int perp=0;// If sensors have equal value they are presumed perpendicular, 1 is left tilt, 2 is right tilt
int align=0;// The difference between the 2 infrared variables
int PeakReading=0;


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released.
*       - Note that this function only sets button1_pushed and button2_pushed flags to true.
*         Your code should clear these flags by setting the appropriate variable to false after
*         the appropriate action has been taken.
*/



typedef enum{
	StartState=0,
	AlignState,
	MoveState,
	DropState,
	ParkState,
	EndState,
}T_FSMState;

T_FSMState FSMState;





void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) & !button2_pushed)
	{
		button2_pushed = true;
	}

	align = SensorValue[in1]-SensorValue[in2];

	if(align>10){
		perp=2;
		}else if(align<-10){
		perp=1;
		}else{
		perp=0;
	}
}

void Turn(int Dir)
{
	clearTimer(T1);
	//1 is a left turn, 0 is a right turn
	if(Dir==1){
		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= -50;
		}

		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= 43;
		}
		motor[motor2]= 0;
		}else{  // If not turning left must be turning right

		while (time1[T1]<=500){
			motor[motor1]= 0;
			motor[motor2]= 50;
		}

		while (time1[T1]>=500&&time1[T1]<=1250){
			motor[motor1]= 55;
			motor[motor2]= 0;
		}
		motor[motor1]= 0;
		while (time1[T1]<=1700&&time1[T1]>=1250){
			motor[motor1]= 0;
			motor[motor2]= -43;
		}
		motor[motor2]= 0;}
}



task main()
{
	button1_pushed = button2_pushed = false;

	while(true){
		switch(FSMState){



		case StartState:
			monitorInput();
			if(button1_pushed==true){
				Turn(1);
				}else if(button2_pushed==true){
				Turn(0);
				}else{
				//turns wheel to 90 degrees, transitions to allighn state
				clearTimer(T1);
				while (time1[T1]<=1000){
					motor[motor2]= 50;
				}
				motor[motor2]= 0;
				FSMState=AlignState;
			}
			break;


			// Detects peak of IR (when robot is best facing sensor)
		case AlignState:
			monitorInput();
			int SensorAv=((SensorValue[in1]+SensorValue[in2])/2);
			motor[motor1]=10;

			// if new peak is achieved it is recorded
			if(SensorAv>PeakReading){
				PeakReading=SensorAv;

				// once significant dropoff occurs wheel goes streight and transitions to move state
				}else if(SensorAv<PeakReading-50){
				motor[motor1]=0;
				clearTimer(T1);
				while (time1[T1]<=1000){
					motor[motor2]= -50;
					FSMState=MoveState;
				}
				break;



			case MoveState:
				monitorInput();
				int static motorSpeed=50; // function ( to be made) slows speed as robot draws nearer
				motor[motor1]=motorSpeed;

				// when led values reach a point, motor is shut off. drop state entered
				if(SensorValue[in1]>5000){
					motor[motor1]=0;
					FSMState=DropState;
				}
				break;


				//Defines behavior when dropping object
			case DropState:
				clearTimer(T1);

				// waits a bit of time before dropping
				while (time1[T1]>=1500&&time1[T1]<=1750){
					motor[motor1]= 0;
					motor[motor3]= -50;
				}
				//after letting go will reverse away from beacon
				while (time1[T1]>=1750&&time1[T1]<=2250){
					motor[motor1]= -50;
					motor[motor3]= 0;
					//  motor[motor2]= 5
				}

				motor[motor1]= 0;

				// transitions to looking to park
				FSMState=ParkState;

				break;

			case ParkState:
				monitorInput();

				break;

			case EndState:

				break;
			}
		}
	}
}
